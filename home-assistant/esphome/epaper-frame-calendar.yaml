# ------------------------------------------------
#           Change configuration here
# ------------------------------------------------
substitutions:
  device_name: epaper-calendar
  friendly_name: "ePaper Calendar"
  
  deep_sleep_duration: 20min
  night_time_deep_sleep_duration: 4h
  
  night_time_start: "22"
  night_time_end: "6"
  
  calendar_data_entity_id: sensor.esp_calendar_data
  calendar_data_update_during_deep_sleep_entity_id: binary_sensor.esp_calendar_data_update_during_deep_sleep
  
  # You can copy a random api key from here: https://esphome.io/components/api.html
  api_key: "api_key_here"
  ota_key: "ota_key_here"
  
  # If you use a different font, you will probably need to adjust the spacing and positions in the code
  font_medium: 'fonts/gotham-rounded/gotham-rounded-medium.ttf'
  font_bold: 'fonts/gotham-rounded/gotham-rounded-bold.ttf'
  font_mdi: 'fonts/material-design-webfont/materialdesignicons-webfont.ttf'
  
  # Specify the full and empty voltage of the battery you use
  battery_full_voltage: "4.2" # in V
  battery_empty_voltage: "3.2" # in V
  
  
# ----------------------------------------------------------------------------------
#             Danger Zone - only change if you know what you are doing
# ----------------------------------------------------------------------------------

esphome:
  name: $device_name
  friendly_name: $friendly_name
  project:
    name: "paulvincentroll.epaper_calendar"
    version: "1.2.0"
  includes:
    - includes/calendar/calendar_utilities.h
    - includes/calendar/text_utilities.h
    - includes/calendar/time_utilities.h
    - includes/calendar/misc_utilities.h
  on_boot:
    - priority: 300.0
      then:
        - if:
            condition:
              # 0 = normal boot
              - lambda: 'return esp_sleep_get_wakeup_cause() == 0;'
            then:
              # Show "waiting for data" screen
              - script.execute: update_screen
    - priority: -100.0
      then:
        - script.execute: boot_script
  on_shutdown:
    - priority: -100.0
      then:
        # Update all sensors 
        - component.update: display_refreshes_sensor
        - component.update: wifi_signal_sensor
        - component.update: last_wake_up_cause
        - component.update: battery_level
          

esp32:
  board: esp-wrover-kit
  framework:
    type: arduino
    
preferences:
  flash_write_interval: 10min
  
deep_sleep:
  id: deep_sleep_1
  wakeup_pin: 
    number: 36
    allow_other_uses: True
    inverted: true
    
http_request:
  id: http_request_data
  useragent: esphome/device
  timeout: 2s
  
# Enable logging
logger:
  logs:
    switch: WARN
    
json:

# Enable Home Assistant API
api:
  encryption:
    key: $api_key
    
select:
    - platform: template
      name: Appearance
      id: appearance
      options:
        - "Light Mode"
        - "Dark Mode"
      initial_option: "Light Mode"
      restore_value: true
      optimistic: true
      entity_category: config
      on_value:
        then:
          - if:
              condition:
                # Only update screen on_value after boot script finished running so we don't 
                # update the screen on receiving the initial state after waking up.
                lambda: 'return id(boot_script_finished_running) == true;'
              then:
                - script.execute: update_screen
    - platform: template
      name: Footer
      id: footer
      options:
        - "Next Event"
        - "Random Quote"
      initial_option: "Next Event"
      restore_value: true
      optimistic: true
      entity_category: config
      on_value:
        then:
          - if:
              condition: 
                # See above
                lambda: 'return id(boot_script_finished_running) == true;'
              then:
                - script.execute: update_screen
          
button:
  - platform: shutdown
    name: Shutdown
    id: shutdown_button
  - platform: restart
    name: Restart
  - platform: template
    name: Refresh Screen
    entity_category: config
    on_press:
      - script.execute: update_screen
      
switch:
  - platform: gpio
    id: battery_read_mosfet
    internal: True
    pin:
      pca6416a: pca6416a_hub
      number: 9
      inverted: false
      
globals:
  - id: data_received
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: display_refreshes
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_display_update_stored
    type: long int
    restore_value: yes
    initial_value: '0'
  - id: battery_empty_symbol_shown
    type: bool
    restore_value: yes
    initial_value: 'true'
  - id: boot_script_finished_running
    type: bool
    restore_value: no
    initial_value: 'false'
    
script:
  - id: update_screen
    then:
      - logger.log: 'Running update_screen script...'
      - if:
          condition:
            and:
              - lambda: 'return id(footer).state == "Random Quote";'
              - wifi.connected
          then:
            - script.execute: fetch_random_quote
      - component.update: inkplate_display
      - lambda: 'id(display_refreshes) += 1;'
      - logger.log: 'Updating last_display_update timestamp...'
      - sensor.template.publish:
          id: last_display_update
          state: !lambda 'return id(homeassistant_time).now().timestamp;'
      
  - id: fetch_random_quote
    then:
      - http_request.get:
          url: "https://api.quotable.io/quotes/random?maxLength=75"
          verify_ssl: false
          on_response:
            then:
              - lambda: |-
                  DynamicJsonDocument doc(1024);
                  DeserializationError error = deserializeJson(doc, id(http_request_data).get_string());
                  
                  if (error) {
                    ESP_LOGD("JSON", "deserializeJson() failed: %s", error.c_str());
                  } else {
                    JsonArray root = doc.as<JsonArray>();
  
                    if (!root.isNull() && root.size() > 0) {
                      JsonObject firstObj = root[0];
                  
                      id(random_quote).publish_state(firstObj["content"]);
                      id(random_quote_author).publish_state(firstObj["author"]);
                    
                    } else {
                      ESP_LOGD("JSON", "Error: Root is not a JSON array or is empty.");
                    }
                  }
                  
  - id: update_screen_if_data_updated
    then:
      - if:
          condition:
            or:
              - binary_sensor.is_on: "calendar_data_update_during_deep_sleep"
              - and:
                  - lambda: 'return id(battery_empty_symbol_shown) == true;'
                  - sensor.in_range:
                      id: battery_level
                      above: 0.0
          then:
            - logger.log: 'Calendar data updated - Refreshing panel...'
            - script.execute: update_screen
          else:
            - logger.log: 'Calendar data has not been updated - Skipping panel refresh...'
      - if:
          condition:
            sensor.in_range:
              id: battery_level
              below: 0.0
          then:
            - logger.log: 'Battery is empty - Refreshing panel to show icon...'
            - script.execute: update_screen
            - logger.log: 'Battery is empty - Shutting down...'
            - button.press: shutdown_button
            
  - id: check_deep_sleep
    then:
          # Wait so some more sensor updates can be pushed out
          - delay: 500ms
          - if:
              condition:
                  - binary_sensor.is_off: disable_deep_sleep
              then:
                - script.execute: enter_deep_sleep
              else:
                - logger.log: 'Deep sleep disabled - Waiting for OTA update...'
                # Suspend component update to reduce frequency when deep sleep is disabled
                - component.suspend: battery_voltage
                
  - id: enter_deep_sleep
    then:
      - lambda: |-
          auto time = id(homeassistant_time).now();

          int night_time_start = $night_time_start;
          int night_time_end = $night_time_end;

          // Default deep sleep duration
          long deep_sleep_duration_in_sec = parse_time_to_seconds("$deep_sleep_duration");
          
          if (time.hour >= night_time_start || time.hour < night_time_end){
            // Night time use extended deep sleep duration
            deep_sleep_duration_in_sec = parse_time_to_seconds("$night_time_deep_sleep_duration");
            ESP_LOGD("deep_sleep_duration_finder", "Default duration (night time): %ld seconds", deep_sleep_duration_in_sec);

            long night_end = seconds_until_night_end(time, night_time_end);
            if (deep_sleep_duration_in_sec > night_end) {
                  deep_sleep_duration_in_sec = night_end;
                  ESP_LOGD("deep_sleep_duration_finder", "Night time duration exceeds end of the configured night time, shortening to: %ld seconds", deep_sleep_duration_in_sec);
            }

          } else {
            ESP_LOGD("deep_sleep_duration_finder", "Default duration (day time): %ld seconds", deep_sleep_duration_in_sec);
          }
          
          // Time until midnight (+ 2s delay)
          long midnight = seconds_until_midnight(time);
          ESP_LOGD("deep_sleep_duration_finder", "Time until day change: %ld seconds", midnight);
          midnight = midnight != 0 ? midnight + 2 : midnight;

          // Time until the next event end time (+ 61s delay)
          long next_event = seconds_until_closest_event_end(time, id(closest_end_time).state);
          ESP_LOGD("deep_sleep_duration_finder", "Time until next event ends: %ld seconds", next_event);
          next_event = next_event != 0 ? next_event + 61 : next_event;

          // Calculate which comes first: default deep sleep duration, midnight, next event ends
          long sleep_durations[3] = {deep_sleep_duration_in_sec, midnight, next_event};
          long next_sleep_duration = find_non_zero_min_in_array(sleep_durations, 3);
          ESP_LOGD("deep_sleep_duration_finder", "Next sleep duration will be: %ld seconds", next_sleep_duration);
          
          // Use result as the next deep sleep duration
          id(deep_sleep_1).set_sleep_duration(next_sleep_duration*1000);

      - deep_sleep.enter:
          id: deep_sleep_1
                
  - id: boot_script
    then:
      - logger.log: 'Running boot script...'
      - wait_until:
          condition: time.has_time
      - sensor.template.publish:
          id: last_wake_up
          state: !lambda 'return id(homeassistant_time).now().timestamp;'
      - wait_until:
          condition:
            lambda: 'return id(data_received) == true;'
      - if:
          condition:
            # 4 = wake up timer
            - lambda: 'return esp_sleep_get_wakeup_cause() == 4;'
          then:
            # Deep sleep wake up - update screen if data has changed
            - script.execute: update_screen_if_data_updated
          else:
            # normal boot or wakeup button - update screen
            - script.execute: update_screen
      - script.execute: check_deep_sleep
      - lambda: 'id(boot_script_finished_running) = true;'
                
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: '*'
        then:
          - if:
              condition:
                - binary_sensor.is_on: disable_deep_sleep
              then:
                - component.update: battery_voltage
      - seconds: 0
        minutes: /5
        then:
          - if:
              condition: 
                lambda: 'return id(boot_script_finished_running) == true;'
              then:
                - script.execute: update_screen_if_data_updated
          
ota:
  - platform: esphome
    password: $ota_key
  
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  
# Include custom fonts
font:
  - file: $font_medium
    id: font_medium_18
    size: 18
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_medium
    id: font_medium_20
    size: 20
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_medium
    id: font_medium_22
    size: 22
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_bold
    id: font_bold_22
    size: 22
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_bold
    id: font_bold_25
    size: 25
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_medium
    id: font_medium_35
    size: 35
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_bold
    id: font_bold_32
    size: 32
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_medium
    id: font_medium_45
    size: 45
    glyphs: [' ', '!', '"', '%', '&', "'", '(', ')', '+', ',', '-', '.', '/', 
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '?', '@', 'A', 
      'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 
      'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', 'a', 'b', 'c', 'd', 
      'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 
      't', 'u', 'v', 'w', 'x', 'y', 'z', '¡', '°', '·', '¿', 'À', 'Á', 'Â', 'Ã', 
      'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ñ', 'Ò', 'Ó', 
      'Ô', 'Õ', 'Ö', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'â', 'ã', 
      'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 
      'ó', 'ô', 'õ', 'ö', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', 'Ā', 'ā', 'Ă', 
      'ă', 'Ą', 'ą', 'Ć', 'ć', 'Ĉ', 'ĉ', 'Č', 'č', 'Ď', 'ď', 'Đ', 'đ', 'Ē', 'ē', 
      'Ė', 'ė', 'Ę', 'ę', 'Ě', 'ě', 'Ĝ', 'ĝ', 'Ğ', 'ğ', 'Ģ', 'ģ', 'Ĥ', 'ĥ', 'Ī', 
      'ī', 'Į', 'į', 'ı', 'Ĵ', 'ĵ', 'Ķ', 'ķ', 'Ĺ', 'ĺ', 'Ļ', 'ļ', 'Ľ', 'ľ', 'Ŀ', 
      'ŀ', 'Ł', 'ł', 'Ń', 'ń', 'Ņ', 'ņ', 'Ň', 'ň', 'Ő', 'ő', 'Œ', 'œ', 'Ŕ', 'ŕ', 
      'Ř', 'ř', 'Ś', 'ś', 'Ŝ', 'ŝ', 'Ş', 'ş', 'Š', 'š', 'Ţ', 'ţ', 'Ť', 'ť', 'Ũ', 
      'ũ', 'Ū', 'ū', 'Ů', 'ů', 'Ű', 'ű', 'Ų', 'ų', 'Ŵ', 'ŵ', 'Ŷ', 'ŷ', 'Ÿ', 'Ź', 
      'ź', 'Ż', 'ż', 'Ž', 'ž', 'Ǎ', 'ǎ', 'Ș', 'ș', 'Ț', 'ț', 'ẞ', 'ạ', 'ấ']
  - file: $font_bold
    id: font_bold_170
    size: 170
    glyphs: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
    
  
  - file: $font_mdi
    id: font_mdi_large
    size: 300
    glyphs:
      # Definitions from https://github.com/kivymd/KivyMD/blob/master/kivymd/icon_definitions.py
      - "\U000f10cd" # battery-alert-variant-outline
      - "\U000F0E8E" # calendar-sync
      
binary_sensor:
  - platform: gpio
    pin:
      inverted: True
      number: 36
      allow_other_uses: True
    id: wake_up_button
    internal: True
    on_click:
      then:
        - script.execute: update_screen
        
  - platform: homeassistant
    id: disable_deep_sleep
    entity_id: input_boolean.disable_deep_sleep
    on_state:
      if:
        condition:
          binary_sensor.is_off: disable_deep_sleep
        then:
          - script.execute: enter_deep_sleep
          
  - platform: homeassistant
    entity_id: $calendar_data_update_during_deep_sleep_entity_id
    id: calendar_data_update_during_deep_sleep
          
sensor:
  - platform: template
    name: Last Display Update
    device_class: timestamp
    entity_category: "diagnostic"
    id: last_display_update
    lambda: "return id(last_display_update_stored);"
    on_value:
      then:
        - lambda: "id(last_display_update_stored) = x;"
    
  - platform: template
    name: Last Wake Up
    device_class: timestamp
    entity_category: "diagnostic"
    id: last_wake_up
    
  - platform: template
    name: Display Refreshes
    id: display_refreshes_sensor
    accuracy_decimals: 0
    unit_of_measurement: "Refreshes"
    state_class: "total_increasing"
    entity_category: "diagnostic"
    lambda: 'return id(display_refreshes);'
    
  - platform: wifi_signal
    name: WiFi Signal Sensor
    id: wifi_signal_sensor
    entity_category: "diagnostic"
    
  - platform: template
    name: Last Wake Up Cause
    id: last_wake_up_cause
    entity_category: "diagnostic"
    accuracy_decimals: 0
    lambda: return esp_sleep_get_wakeup_cause();
    
  - platform: homeassistant
    entity_id: $calendar_data_entity_id
    attribute: closest_end_time
    id: closest_end_time
    
    
  - platform: adc
    id: battery_adc
    update_interval: never
    attenuation: 11db
    internal: True
    pin: 35
    
  - platform: template
    name: "Battery Voltage"
    id: battery_voltage
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    entity_category: diagnostic
    update_interval: 5ms
    lambda: |-
      id(battery_read_mosfet).turn_on();
      delay(1);
      float adc = id(battery_adc).sample();
      id(battery_read_mosfet).turn_off();
      return adc;
    filters:
      - multiply: 2
      - min:
          window_size: 50
          send_every: 50
          send_first_at: 50
          
  - platform: template
    name: "Battery Level"
    id: battery_level
    entity_category: diagnostic
    device_class: battery
    unit_of_measurement: '%'
    lambda: |-
      return id(battery_voltage).state;
    filters:
      - calibrate_linear:
          - $battery_empty_voltage -> 0.0
          - $battery_full_voltage -> 100
      - clamp:
          min_value: 0
          max_value: 100
    on_value_range:
      - below: 0.0
        then:
          - script.execute: update_screen
          
text_sensor:
  - platform: homeassistant
    entity_id: $calendar_data_entity_id
    attribute: entries
    id: calendar_json
    on_value:
      then:
         - lambda: 'id(data_received) = true;'
          
  - platform: template
    id: random_quote_author
  - platform: template
    id: random_quote
    
  - platform: homeassistant
    entity_id: $calendar_data_entity_id
    attribute: todays_day_name
    id: todays_day_name
    
  - platform: homeassistant
    entity_id: $calendar_data_entity_id
    attribute: todays_date_month_year
    id: todays_date_month_year
    
i2c:

pca6416a:
  - id: pca6416a_hub
    address: 0x20
    
display:
- platform: inkplate6
  id: inkplate_display
  greyscale: false
  partial_updating: false
  update_interval: never
  full_update_every: 5
  model: inkplate_6_v2
  rotation: 90°
  
  ckv_pin: 32
  sph_pin: 33
  gmod_pin:
    pca6416a: pca6416a_hub
    number: 1
  gpio0_enable_pin:
    pca6416a: pca6416a_hub
    number: 8
  oe_pin:
    pca6416a: pca6416a_hub
    number: 0
  spv_pin:
    pca6416a: pca6416a_hub
    number: 2
  powerup_pin:
    pca6416a: pca6416a_hub
    number: 4
  wakeup_pin:
    pca6416a: pca6416a_hub
    number: 3
  vcom_pin:
    pca6416a: pca6416a_hub
    number: 5
  lambda: |-
      std::map < std::string, std::string > icon_map {
        {
          "battery-alert-variant-outline",
          "\U000f10cd"
        }, {
          "calendar-sync",
          "\U000F0E8E"
        }
      };
      
      auto color_content = Color::WHITE;
      auto color_background = Color::BLACK;
      
      auto index = id(appearance).active_index();
      
      if (index.has_value()) {
        if (index.value() == 0) {
          ESP_LOGD("custom", "Light Mode is selected - using black text on a white background.");
          color_content = Color::BLACK;
          color_background = Color::WHITE;
        } else {
          ESP_LOGD("custom", "Dark Mode is selected - using white text on a black background.");
        }
      }
      
      // Fill background in black.
      it.fill(color_background);
      
      if (id(battery_level).state == 0.0) {
        id(battery_empty_symbol_shown) = true;
        it.printf(300, 400, id(font_mdi_large), color_content, TextAlign::CENTER, "%s", icon_map["battery-alert-variant-outline"].c_str());
      } else {
        id(battery_empty_symbol_shown) = false;
      
        if (id(data_received) == false) {
          it.printf(300, 400, id(font_mdi_large), color_content, TextAlign::CENTER, "%s", icon_map["calendar-sync"].c_str());
          it.printf(300, 780, id(font_medium_20), color_content, TextAlign::BOTTOM_CENTER, "Waiting for data...");
        } else {
          auto time = id(homeassistant_time).now();
      
          // Calculate today date width
          int day_of_month_width = get_text_width( & it, id(font_bold_170), "%d", time.day_of_month);
          int todays_day_name_width = get_text_width( & it, id(font_medium_35), "%s", id(todays_day_name).state.c_str());
          int day_title_width = get_text_width( & it, id(font_medium_20), "%s", id(todays_date_month_year).state.c_str());
          
          int todays_date_widths[3] = {day_of_month_width, todays_day_name_width, day_title_width};
          int max_todays_date_width = find_max_in_array(todays_date_widths, 3);
          
          
          int todays_date_x_offset = 20;

          int calendar_x_pos = 260;
          int calendar_y_pos = 35; 

          int days_padding_bottom = 10;
      
          int circle_size = 17;
      
          int cell_size_width = 50;
          int cell_size_height = 30;
          
          
          if (max_todays_date_width > 210) {
            todays_date_x_offset = 13;
            calendar_x_pos = 280;
            cell_size_width = 48;
          }
          
          it.printf(max_todays_date_width / 2 + todays_date_x_offset, 10, id(font_bold_170), color_content, TextAlign::TOP_CENTER, "%d", time.day_of_month);
          it.printf(max_todays_date_width / 2 + todays_date_x_offset, 159, id(font_medium_35), color_content, TextAlign::TOP_CENTER, "%s", id(todays_day_name).state.c_str());
          it.printf(max_todays_date_width / 2 + todays_date_x_offset, 193, id(font_medium_20), color_content, TextAlign::TOP_CENTER, "%s", id(todays_date_month_year).state.c_str());
      
          // Draw Calendar
      
          char cal[7][7][3]; // Calendar matrix including weekdays
          int days_line_left_position = 0;
          int days_line_right_position = 0;
      
          get_calendar_matrix(time.year, time.month, cal);
      
          for (int i = 0; i < 7; i++) {
            for (int j = 0; j < 7; j++) {
              int x_pos = calendar_x_pos + cell_size_width * j;
              int y_pos = calendar_y_pos + cell_size_height * i;
      
              if (i == 0) {
                // Header (day names)
                it.printf(x_pos, y_pos, id(font_bold_25), color_content, TextAlign::CENTER, "%s", cal[i][j]);
                if (j == 0) {
                  days_line_left_position = x_pos - (get_text_width( & it, id(font_bold_22), "%s", cal[i][j]) / 2);
                } else if (j == 6) {
                  days_line_right_position = x_pos + (get_text_width( & it, id(font_bold_22), "%s", cal[i][j]) / 2);
                }
              } else {
                // Day numbers
                y_pos += days_padding_bottom;
                if (atoi(cal[i][j]) == time.day_of_month) {
                  // Highlight current day
                  it.filled_circle(x_pos, y_pos - 1, circle_size, color_content);
                  it.printf(x_pos, y_pos, id(font_bold_22), color_background, TextAlign::CENTER, "%s", cal[i][j]);
                } else {
                  it.printf(x_pos, y_pos, id(font_medium_22), color_content, TextAlign::CENTER, "%s", cal[i][j]);
                }
              }
            }
            if (i == 1) {
              it.line(days_line_left_position, calendar_y_pos + (cell_size_height / 2), days_line_right_position, calendar_y_pos + (cell_size_height / 2), color_content);
            }
          }
      
          // End Draw Calendar
      
          it.filled_rectangle(0, 230, 600, 3, color_content);
      
          // Draw event list
      
          DynamicJsonDocument doc(4096);
          deserializeJson(doc, id(calendar_json).state.c_str());
          JsonArray entries = doc.as<JsonArray>();
      
          int current_y_position = 250; // Initial vertical position
          const int max_y_position = 682; // Maximum vertical position
          const int events_top_padding = 5; // Padding top first event within a day
          const int event_spacing = 10; // Spacing between the events within a day
          const int events_bottom_padding = 5; // Padding after the last entry of the day
          const int day_spacing = 15; // Spacing between different days
      
          int max_event_title_length = 30; // Max characters event title 
          int max_event_subtitle_length = 44; // Max characters event subtitle 
      
          for (JsonVariant entry: entries) {
            int day_number = entry["day"].as < int > ();
            const char * day_name = entry["day_name"];
      
            // Calculate day title height
            int day_number_height = get_text_height( & it, id(font_medium_45), "%d", day_number);
            int day_name_height = get_text_height( & it, id(font_medium_20), "%s", day_name);
            int day_title_height = day_number_height + day_name_height; // Total space needed for the day title
      
            // Check if there's enough space for the day's title before drawing
            if (current_y_position + day_title_height > max_y_position) break;
      
            // Draw day title
            it.printf(45, current_y_position, id(font_medium_45), color_content, TextAlign::TOP_CENTER, "%d", day_number);
            it.printf(45, current_y_position + day_number_height - 5, id(font_medium_20), color_content, TextAlign::TOP_CENTER, "%s", day_name);
      
            int entry_y_position = current_y_position + events_top_padding; // Initialize entry_y_position to align with the day number + optional padding
      
            auto processEntry = [ & ](const JsonVariant & item) -> bool {
              std::string summary = item["summary"].as < std::string > ();
              const char * start = item["start"];
              const char * end = item["end"];
              const char * location_name = item["location_name"];
              const char * calendar_name = item["calendar_name"];

              // Create copy we can modify
              int max_event_title_chars = max_event_title_length; 
              int max_event_subtitle_chars = max_event_subtitle_length; 
      
              std::string start_time = start ? extract_time(start) : "";
              std::string end_time = end ? extract_time(end) : "";
      
              // start_time == empty => day event (check if multiple days to add that information)
              if (start_time.empty()) {
      
                // Get current date in format yyyy-mm-dd
                auto get_current_date_str = []() -> std::string {
                  auto now = id(homeassistant_time).now();
      
                  char buffer[11];
                  sprintf(buffer, "%d-%02d-%02d", now.year, now.month, now.day_of_month);
      
                  return std::string(buffer);
                };
      
                // Calculate length of event in days
                int days = days_between_dates(start, end);
      
                // If event is longer than just today
                if (days > 1) {
                  if (start == get_current_date_str()) {
                    // Event is today
                    // Subtract today from the length in days
                    days -= 1;
                    end_time = "left";
                  } else {
                    end_time = "long";
                  }
      
                  start_time = std::to_string(days) + ((days > 1) ? " days" : " day");
      
                } else {
                  // Event won't have time information so the title and subtitle can be longer
                  max_event_title_chars += 4;
                  max_event_subtitle_chars += 6;
                }
              }
      
              std::string subtitle_string = std::string(calendar_name) + (location_name && strlen(location_name) > 0 ? " · " + std::string(location_name) : "");
              if (subtitle_string.length() > max_event_subtitle_chars) {
                subtitle_string = subtitle_string.substr(0, max_event_subtitle_chars - 3) + "...";
              }
      
              if (summary.length() > max_event_title_chars) {
                summary = summary.substr(0, max_event_title_chars - 3) + "...";
              }
      
              int summary_height = get_text_height( & it, id(font_bold_25), "%s", summary.c_str());
              int subtitle_height = get_text_height( & it, id(font_medium_18), "%s", subtitle_string.c_str());
      
              // Check if event will still fit
              if (entry_y_position + summary_height + subtitle_height + event_spacing <= max_y_position) {
                // Draw event summary
                it.printf(100, entry_y_position, id(font_bold_25), color_content, TextAlign::TOP_LEFT, "%s", summary.c_str());
      
                // Draw start time
                if (!start_time.empty()) {
                  it.printf(590, entry_y_position, id(font_bold_25), color_content, TextAlign::TOP_RIGHT, "%s", start_time.c_str());
                }
      
                entry_y_position += summary_height + 2;
      
                // Draw subtitle string (calendar name and location)
                it.printf(100, entry_y_position, id(font_medium_18), color_content, TextAlign::TOP_LEFT, "%s", subtitle_string.c_str());
      
                // Draw end time
                if (!end_time.empty()) {
                  it.printf(590, entry_y_position, id(font_medium_18), color_content, TextAlign::TOP_RIGHT, "%s", end_time.c_str());
                }
      
                entry_y_position += subtitle_height + event_spacing;
      
                // Event drawn - return true
                return true;
              } else {
                // Event did not fit and was not drawn - return false
                return false;
              }
            };
      
            JsonArray all_day = entry["all_day"];
            JsonArray other = entry["other"];
      
            for (JsonVariant item: all_day) {
              if (!processEntry(item)) break;
            }
      
            for (JsonVariant item: other) {
              if (!processEntry(item)) break;
            }
      
            entry_y_position += events_bottom_padding - event_spacing;
      
            // Draw the vertical line next to the day titles and events
            it.line(85, current_y_position, 85, entry_y_position, color_content);
      
            // Update current_y_position for the next day, ensuring space between days
            current_y_position = entry_y_position + day_spacing;
          }
      
          // End Draw event list
      
          // Draw Footer
      
          auto index = id(footer).active_index();
      
          if (index.has_value()) {
            if (index.value() == 0) {
              it.printf(10, 704, id(font_bold_22), color_content, TextAlign::BOTTOM_LEFT, "%s", "Next Appointment:");
              it.filled_rectangle(0, 707, 600, 3, color_content);
              it.filled_rectangle(0, 712, 600, 88, color_content);
      
              JsonObject first_day = doc["entries"][0].as < JsonObject > ();
      
              // Initialise a flag to determine whether to print the no more events message
              bool no_upcoming_events_today = true;
      
              // Check if "entries" exists and has at least one element
              if (doc.containsKey("entries") && doc["entries"].is < JsonArray > () && doc["entries"].size() > 0) {
                JsonObject first_day = doc["entries"][0].as < JsonObject > ();
      
                // Check if 'is_today' is true and 'other' array has events
                if (first_day.containsKey("is_today") && first_day["is_today"].as < int > () == 1 &&
                  first_day.containsKey("other") && first_day["other"].is < JsonArray > () && first_day["other"].size() > 0) {
      
                  // There's an event today, so set flag to not print the no more appointments message
                  no_upcoming_events_today = false;
      
                  // Safe to access entries[0]["other"][0] and proceed with displaying event details
                  JsonObject next_event = first_day["other"][0];
      
                  const char * summary = next_event["summary"];
                  const char * start = next_event["start"];
                  const char * end = next_event["end"];
                  const char * location_name = next_event["location_name"];
                  const char * calendar_name = next_event["calendar_name"];
      
                  std::string start_time = start ? extract_time(start) : "";
                  std::string end_time = end ? extract_time(end) : "";
      
                  std::string subtitle_string = (location_name != nullptr) ? (std::string(calendar_name) + " · " + std::string(location_name)) : std::string(calendar_name);
                  if (subtitle_string.length() > 45) {
                    subtitle_string = subtitle_string.substr(0, 42) + "...";
                  }
      
                  it.printf(10, 726, id(font_bold_32), color_background, TextAlign::TOP_LEFT, "%s", summary);
                  it.printf(12, 786, id(font_medium_22), color_background, TextAlign::BOTTOM_LEFT, "%s", subtitle_string.c_str());
      
                  it.printf(590, 726, id(font_bold_32), color_background, TextAlign::TOP_RIGHT, "%s", start_time.c_str());
                  it.printf(588, 786, id(font_medium_22), color_background, TextAlign::BOTTOM_RIGHT, "%s", end_time.c_str());
                }
              }
      
              // Check the flag to decide whether to print the no more appointments message
              if (no_upcoming_events_today) {
                it.printf(300, 740, id(font_bold_32), color_background, TextAlign::TOP_CENTER, "%s", "No further appointments today");
              }
            } else {
              it.filled_rectangle(0, 685, 600, 3, color_content);
              it.filled_rectangle(0, 690, 600, 110, color_content);
      
              const int max_characters_per_line = 40;
              const char * quote = id(random_quote).state.c_str();
              size_t quote_length = std::strlen(quote);
      
              std::string first_part;
              std::string rest;
      
              if (quote_length > max_characters_per_line) {
                // Calculate the midpoint for an optimal split
                int midpoint = quote_length / 2;
                int split_pos_left = midpoint;
                int split_pos_right = midpoint;
      
                // Search for the nearest space around the midpoint
                while (split_pos_left > 0 && quote[split_pos_left] != ' ') split_pos_left--;
                while (split_pos_right < quote_length && quote[split_pos_right] != ' ') split_pos_right++;
      
                // Choose the closest split position that doesn't exceed max characters per line
                int split_pos;
                if (midpoint - split_pos_left <= split_pos_right - midpoint && split_pos_left > 0) {
                  split_pos = split_pos_left;
                } else if (split_pos_right < quote_length) {
                  split_pos = split_pos_right;
                } else {
                  // Default split position if no spaces are found near midpoint (unlikely due to search logic)
                  split_pos = midpoint;
                }
      
                // Split the quote at the determined position
                first_part = std::string(quote, quote + split_pos);
                rest = std::string(quote + split_pos + 1);
      
                // Display the split quote
                it.printf(300, 710, id(font_bold_25), color_background, TextAlign::TOP_CENTER, "%s", first_part.c_str());
                it.printf(300, 737, id(font_bold_25), color_background, TextAlign::TOP_CENTER, "%s", rest.c_str());
                it.printf(300, 785, id(font_medium_18), color_background, TextAlign::BOTTOM_CENTER, "%s", id(random_quote_author).state.c_str());
              } else {
                // Display the quote without splitting if it doesn't exceed the maximum characters per line
                it.printf(300, 720, id(font_bold_25), color_background, TextAlign::TOP_CENTER, "%s", id(random_quote).state.c_str());
                it.printf(300, 770, id(font_medium_18), color_background, TextAlign::BOTTOM_CENTER, "%s", id(random_quote_author).state.c_str());
              }
      
            }
          }
          // End Draw Footer
        }
      }
